<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Codecflow-style ASCII Background</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Inter", sans-serif;
      overflow: hidden;
    }

    /* Fullscreen canvas behind everything */
    #bg-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: -1;
    }

    /* Simple hero content to mimic codecflow feel */
    .hero {
      position: relative;
      height: 100vh;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 2rem;
      pointer-events: none; /* so you can’t accidentally select text instead of feeling like a hero page */
    }

    .hero-badge {
      font-size: 0.75rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 1.5rem;
    }

    .hero-title {
      font-size: clamp(2.8rem, 5vw, 4.2rem);
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 1rem;
    }

    .hero-title span {
      color: #fff;
    }

    .hero-subtitle {
      max-width: 640px;
      color: #b3b3b3;
      font-size: 0.95rem;
      line-height: 1.6;
    }

    .hero-subtitle strong {
      color: #fff;
      font-weight: 500;
    }

    /* Very subtle top/bottom fade for “cinematic” look */
    .vignette {
      pointer-events: none;
      position: fixed;
      inset: 0;
      background:
        linear-gradient(to bottom, rgba(0,0,0,0.85), transparent 20%, transparent 80%, rgba(0,0,0,0.9));
      mix-blend-mode: multiply;
      z-index: -1;
    }
  </style>
</head>
<body>
  <!-- Background ASCII canvas -->
  <canvas id="bg-canvas" style="position:fixed;inset:0;width:100vw;height:100vh;display:block;z-index:0;background:#000"></canvas>
  <div class="vignette"></div>

  <!-- Hero content (edit this to whatever you want) -->

  <!-- Your advanced.js must sit in the same folder as this file -->
  <script type="module">
    import {
      R as Renderer,   // WebGL renderer
      C as Camera,     // Camera
      g as Plane,      // Plane geometry
      M as Mesh,       // Mesh
      P as Program,    // Shader program
      V as Vec3,       // vec3 helper
      e as Node,       // base Scene/Node
      A as AsciiPass,  // ASCII post effect
      i as EffectStack // Effect chain manager
    } from "./advanced.js";

    const canvas = document.getElementById("bg-canvas");

    // --- Renderer / GL setup ---
    const renderer = new Renderer({
      canvas,
      dpr: Math.min(window.devicePixelRatio, 2),
      alpha: false,
      depth: true,
      antialias: true
    });
    const gl = renderer.gl;

    // --- Scene & Camera ---
    const scene = new Node();

    // Perspective camera (matches original advanced.js sample usage)
    const camera = new Camera(gl, {
      fov: 45,
      aspect: window.innerWidth / window.innerHeight,
      near: 0.1,
      far: 100
    });
    camera.position.set(0, 0, 2);
    camera.lookAt(new Vec3(0, 0, 0));

    // --- Geometry: fullscreen plane (NDC-sized with perspective)
    const geometry = new Plane(gl, {
      width: 2,
      height: 2,
      widthSegments: 1,
      heightSegments: 1
    });

    // --- Shaders for the base grayscale effect (before ASCII) ---

    // Vertex shader: standard MVP transform
    const vertexShader = /* glsl */ `
      attribute vec3 position;
      attribute vec2 uv;

      uniform mat4 modelMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 projectionMatrix;

      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position =
          projectionMatrix *
          viewMatrix *
          modelMatrix *
          vec4(position, 1.0);
      }
    `;

    // Fragment shader: slow, subtle radial + scanline motion, grayscale only
    const fragmentShader = /* glsl */ `
      precision highp float;

      varying vec2 vUv;
      uniform float uTime;

      // tiny hash for grain
      float hash(vec2 p) {
        p = fract(p * vec2(123.34, 456.21));
        p += dot(p, p + 45.32);
        return fract(p.x * p.y);
      }

      void main() {
        // Centered UV
        vec2 uv = vUv - 0.5;
        uv.x *= 1.6;        // slight stretch horizontally

        float r = length(uv);

        // Very slow radial breathing
        float radial = 0.5 + 0.5 * sin(r * 18.0 - uTime * 0.8);

        // Soft horizontal scanlines moving slowly upwards
        float scan = 0.5 + 0.5 * sin((uv.y * 140.0) - uTime * 1.0);

        // Combine them
        float base = radial * scan;

        // Add a hint of grain to stop it feeling too flat
        float grain = (hash(uv * 800.0 + uTime * 0.1) - 0.5) * 0.15;

        float shade = clamp(base + grain, 0.0, 1.0);

        // Curve brightness so mid-tones are softer
        shade = pow(shade, 1.4);

        gl_FragColor = vec4(vec3(shade), 1.0);
      }
    `;

    // --- Program & Mesh ---
    const program = new Program(gl, {
      vertex: vertexShader,
      fragment: fragmentShader,
      uniforms: {
        uTime: { value: 0 }
      },
      transparent: false,
      depthTest: false,
      depthWrite: false
    });

    const mesh = new Mesh(gl, { geometry, program });
    scene.addChild(mesh);

    // === ASCII POST EFFECT (CODE-LIKE) ===
    // Longer, smoother ramp: whitespace -> punctuation -> digits -> letters -> heavy symbols
    const codeChars = "123456789 qwertyuiop[]asdfghjkl;' zxcvb nm,./<>?:zxcvbnm,. /<>?:zxcvbn m,./<>?:zxcvbn m,./<>?:";
    const ascii = new AsciiPass(gl, {
      charSize: 13,
      charLength: codeChars.length,
      pixels: false,
      greyscale: false,
      overwriteColor: true,
      color: '#ffffff',
      characters: codeChars
    });
    const effects = new EffectStack(gl);
    effects.add('ascii', ascii);

    // --- Resize handling ---
    function onResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      renderer.setSize(width, height);

      // Maintain aspect for the perspective camera
      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      // Update post effect FBO sizes
      ascii.resize();
    }

    window.addEventListener("resize", onResize);
    onResize();

    // --- Render loop ---
    let lastTime = 0;
    function loop(now) {
      const t = now * 0.0001; // ms → seconds
      const dt = t - lastTime;
      lastTime = t;

      // Drive a very slow shader time; keep visuals subtle
      program.uniforms.uTime.value = t * 0.0005; // 0.05% of real time

      // Update ASCII more slowly as well
      ascii.update(t * 0.005);
      effects.render({ scene, camera });
0
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
